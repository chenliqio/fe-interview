思路：
采用洗牌算法，保证每个元素出现在每一个位置的概率相同。
- 我们从后往前取一个基准数 a。
- 然后从未洗牌的区间随机取一个数b（a也在未洗牌的区域内),a b 交换。
- 从后往前，重复上述步骤。
如果上面的解法思路是正确的的,那么，如果我们随机10000次,每个位置上加起来的数的平均数应该约等于4.5，

```
let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
let res = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function shuffle(arr) {
    let len = arr.length;
    for (let i = 0; i < len; i++) {
        // -i 从后面
        // 从前面随机取一个数的下标
        // Math.floor(x) 返回小于等于x的最大整数 向下取整
        let idx = Math.floor(Math.random() * (len - i));
        [arr[len - 1 - i], arr[idx]] = [arr[idx], arr[len - 1 - i]];
    }
    return arr;
}
let t = 10000;
for (let i = 0; i < t; i++) {
    // 对数组先进行浅拷贝
    let sorted = shuffle(arr.slice(0));
    for (let i = 0; i < sorted.length; i++) {
        res[i] = sorted[i] + res[i];
    }
}
console.log(res.map(sum => sum / t));
```